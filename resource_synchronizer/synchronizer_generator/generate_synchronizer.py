import argparse
import os
import sys
from typing import NamedTuple, List
import string

ResourceManager = NamedTuple("ResourceManager", [("type", str), ("name", str)])

SubFsm = NamedTuple("SubFsm", [("type", str), ("res_name", str), ("name", str)])
Settings = NamedTuple("Settings", [("sub_fsms", List[SubFsm]), ("project_name", str), ("class_name", str), ("project_name_msgs", str),
                                   ("unique_msgs_deps", List[str])])

def type_and_name(double_points_str):
    sp = double_points_str.split(':')
    if len(sp) != 2:
        raise argparse.ArgumentTypeError("'{}' is not a valid resource manager format. Format should be 'resource_manager_type:resource_manager_name'")
    return ResourceManager(*sp)

def create_msg_and_srv_files(package_msg_dir, dependencies):
    msgs_files = []
    srvs_files = []
    fsm_srv_file_name = os.path.join(package_msg_dir, "srv", "MetaStateMachine.srv")
    fsm_srv_file = "resource_synchronizer_msgs/MetaStateMachineHeader header\n"
    for dep in dependencies:
        msg_file_name = "SubStateMachine_{type}".format(type=dep.type)
        subsm_msg_name = os.path.join(package_msg_dir, "msg", "{msg_file_name}.msg".format(msg_file_name=msg_file_name))
        with open(subsm_msg_name, "w") as f:
            f.write("resource_synchronizer_msgs/SubStateMachineHeader header\n"
                    "{type}/StateMachine state_machine".format(type=dep.type))
        msgs_files.append("{msg_file_name}.msg".format(msg_file_name=msg_file_name))
        fsm_srv_file += ("{msg_file_name} state_machine_{name}\n".format(msg_file_name=msg_file_name, name=dep.name))
    fsm_srv_file += "---\nint32 id\nstring error"
    with open(fsm_srv_file_name, "w") as f:
        f.write(fsm_srv_file)
    srvs_files.append("MetaStateMachine.srv")

    return msgs_files, srvs_files

def create_catkin_files_msgs(package_name, package_dir, dependencies, msgs_to_gen, srvs_to_gen):
    unique_dep_type = set([d.type for d in dependencies])
    # CmakeLists.txt for msgs package
    with open(os.path.join(package_dir, "CMakeLists.txt"),"w") as fcmake:
        fcmake.write("cmake_minimum_required(VERSION 2.8.3)\n"
                     "project({package_name})\n".format(package_name=package_name)+
                     "\n"
                     "find_package(catkin REQUIRED\n"
                     "roscpp\n"
                     "message_generation\n"
                     "resource_management_msgs\n"
                     "resource_synchronizer_msgs\n"
                     +"\n".join(unique_dep_type)+"\n"
                     ")\n"
                     "\n"
                     "## Generate messages in the \'msg\' folder\n"
                     "add_message_files(\n"
                     "FILES\n"
                     +"\n".join(msgs_to_gen)+"\n"
                     ")\n"
                     "   \n"
                     "## Generate services in the \'srv\' folder\n"
                     "add_service_files(\n"
                     "FILES\n"
                     +"\n".join(srvs_to_gen)+"\n"
                     ")\n"
                     "   \n"
                     "generate_messages(DEPENDENCIES resource_management_msgs resource_synchronizer_msgs {catkin_msgs_deps})\n"
                     "\n"
                     "catkin_package(CATKIN_DEPENDS message_runtime {catkin_msgs_deps})".format(catkin_msgs_deps=" ".join(unique_dep_type)))

    pack_deps = ['\t<depend>'+d+'</depend>\n' for d in unique_dep_type]
    # package.xml
    with open(os.path.join(package_dir, "package.xml"),"w") as fpackage:
        fpackage.write('<package format="2">\n'
                       '\t<name>{package_name}</name>\n'.format(package_name=package_name)+
                       '\t<version>0.0.0</version>\n'
                       '\t<description>\n'
                       '\t\t{0} package autogenerated from resource_synchronizer messages generator.\n'.format(package_name)+
                       '\t</description>\n'
                       '\t<maintainer email="todo@todo.org">TBD</maintainer>\n'
                       '\t<license>TBD</license>\n'
                       '\n'
                       '\t<depend>roscpp</depend>\n'
                       '\t<depend>resource_management_msgs</depend>\n'
                       '\t<depend>resource_synchronizer_msgs</depend>\n'
                       +"".join(pack_deps)+
                       '\t<buildtool_depend>catkin</buildtool_depend>\n'
                       '\t<build_depend>message_generation</build_depend>\n'
                       '\t<exec_depend>message_runtime</exec_depend>\n'
                       '</package>\n')

def create_catkin_files_src(package_name, package_dir, package_msgs_name):
    # CmakeLists.txt for src package
    with open(os.path.join(package_dir, "CMakeLists.txt"),"w") as fcmake:
        fcmake.write("cmake_minimum_required(VERSION 2.8.3)\n"
                     "project({package_name})\n"
                     "\n"
                     "add_compile_options(-std=c++14 -Wall -Wextra -pthread)\n"
                     "\n"
                     "find_package(catkin REQUIRED\n"
                     "roscpp\n"
                     "resource_management\n"
                     "resource_synchronizer\n"
                     "resource_management_msgs\n"
                     "resource_synchronizer_msgs\n"
                     "{package_msgs_name}\n"
                     ")\n"
                     "\n"
                     "catkin_package(CATKIN_DEPENDS message_runtime {package_msgs_name})\n"
                     "\n"
                     "find_package (Threads)\n"
                     "\n"
                     "include_directories(\n"
                     "  include\n"
                     "  ${{catkin_INCLUDE_DIRS}}\n"
                     "  ${{INCLUDE_DIRS}}\n"
                     ")\n"
                     "\n"
                     "add_executable(synchronizer src/{package_name}.cpp)\n"
                     "add_dependencies(synchronizer ${{${{PROJECT_NAME}}_EXPORTED_TARGETS}} ${{catkin_EXPORTED_TARGETS}})\n"
                     "target_link_libraries(synchronizer\n${{catkin_LIBRARIES}}\n)\n"
                     "\n".format(package_name=package_name, package_msgs_name=package_msgs_name))

    # package.xml
    with open(os.path.join(package_dir, "package.xml"),"w") as fpackage:
        fpackage.write('<package format="2">\n'
                       '\t<name>{package_name}</name>\n'.format(package_name=package_name)+
                       '\t<version>0.0.0</version>\n'
                       '\t<description>\n'
                       '\t\t{0} package autogenerated from resource_synchronizer generator.\n'
                       '\t</description>\n'
                       '\t<maintainer email="todo@todo.org">TBD</maintainer>\n'
                       '\t<license>TBD</license>\n'
                       '\n'
                       '\t<depend>roscpp</depend>\n'
                       '\t<depend>resource_management</depend>\n'
                       '\t<depend>resource_synchronizer</depend>\n'
                       '\t<depend>resource_management_msgs</depend>\n'
                       '\t<depend>resource_synchronizer_msgs</depend>\n'
                       '\t<depend>{package_msgs_name}</depend>\n'.format(package_name, package_msgs_name=package_msgs_name)+
                       '\t<buildtool_depend>catkin</buildtool_depend>\n'
                       '\t<build_depend>message_generation</build_depend>\n'
                       '\t<exec_depend>message_runtime</exec_depend>\n'
                       '</package>\n')

def create_launch_file(package_name, launch_file_dir, dependencies):
    with open(os.path.join(launch_file_dir, package_name + ".launch"),"w") as flaunch:  # Les l√©gumes sont a vaunlunte !
        flaunch.write("<launch>\n")
        for dep in dependencies:
            flaunch.write('\t<node name="{dep_name}" pkg="{dep_type}" type="{dep_type}" output="screen" />\n'.format(
                dep_name=dep.name, dep_type=dep.type
            ))
        flaunch.write('\t<node name="{package_name}" pkg="{package_name}" type="synchronizer" output="screen" />\n'.format(
            package_name=package_name
        ))
        flaunch.write("</launch>")

def underscore_to_CamelCase(word):
    return ''.join(x.capitalize() or '_' for x in word.split('_'))

def substitue_for_loop(tpl,for_var,the_list):
    res=""
    for x in the_list:
        res+=eval('tpl.format({}=x)'.format(for_var))
    return res

def substitue_fmt(tpl,unused0,the_var):
    return tpl.format(the_var)


def configure_template(template_path, output_path, msgs_dep, project_name, package_msgs_name):
    sub_fsms = [SubFsm("SubStateMachine_{type}".format(type=d.type), d.type, d.name) for d in msgs_dep]
    unique_deps = list(set([d.type for d in msgs_dep]))
    settings = Settings(sub_fsms, project_name, underscore_to_CamelCase(project_name), package_msgs_name, unique_deps)
    f_in = open(template_path,'r')
    tpl = ""
    tpl_inside=""
    for_var=""
    inside=False
    for line in f_in:
        if line.startswith('!!for '):
            inside='for_loop'
            command=line[2:-1]
            for_var=command[command.find(' ')+1:]
            for_var=for_var[0:for_var.find(' ')]
            for_list=command[command.find(' in ')+4:]
            tpl_inside=""
        elif line.startswith('!!fmt '):
            inside='fmt'
            command=line[2:-1]
            for_list=command[command.find(' ')+1:]
            tpl_inside=""
        elif line.startswith('!!end'):
            tpl+=eval('substitue_{}(tpl_inside,for_var,settings.{})'.format(inside,for_list))
            inside=None
        elif inside:
            tpl_inside+=line
        else:
            tpl+=line
    f_in.close()

    # write main cpp file

    fo = open(output_path,"w+")
    fo.write(string.Template(tpl).substitute(**settings._asdict()))
    fo.close()

if __name__ == "__main__":
    argparser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    argparser.add_argument(dest='package_name', help="The name of the created synchronizer package")
    argparser.add_argument(dest='dependencies', nargs="+",
                           help="The resource managers package name to synchronize (must be in the same workspace)",
                           type=type_and_name)
    args = argparser.parse_args()

    package_msg_name = args.package_name+"_msgs"
    package_msg_dir = os.path.join(args.package_name, package_msg_name)
    package_src_dir = os.path.join(args.package_name, args.package_name)
    generator_dir=os.path.dirname(sys.argv[0])
    os.makedirs(os.path.join(package_src_dir, "src"))
    os.makedirs(os.path.join(package_src_dir, "include"))
    os.makedirs(os.path.join(package_msg_dir, "msg"))
    os.makedirs(os.path.join(package_msg_dir, "srv"))
    os.makedirs(os.path.join(package_src_dir, "launch"))

    msgs_dep = [ResourceManager(d.type + "_msgs", d.name) for d in args.dependencies]

    msgs_to_gen, srvs_to_gen = create_msg_and_srv_files(package_msg_dir, msgs_dep)

    create_catkin_files_msgs(package_msg_name, package_msg_dir, msgs_dep, msgs_to_gen, srvs_to_gen)

    create_catkin_files_src(args.package_name, package_src_dir, package_msg_name)

    configure_template(os.path.join(generator_dir, "template_resource_synchronizer.h"), os.path.join(package_src_dir, "include", args.package_name + ".h"),
                       msgs_dep, args.package_name, package_msg_name)

    configure_template(os.path.join(generator_dir, "template_resource_synchronizer.cpp"),
                       os.path.join(package_src_dir, "src", args.package_name + ".cpp"),
                       msgs_dep, args.package_name, package_msg_name)

    create_launch_file(args.package_name, os.path.join(package_src_dir, "launch"), args.dependencies)
